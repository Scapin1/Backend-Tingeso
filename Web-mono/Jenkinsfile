// Jenkinsfile (Declarativo)

pipeline {
    agent any

    // ------------------------------------------------------------------
    // 1. CONFIGURACIÓN INICIAL Y HERRAMIENTAS
    // ------------------------------------------------------------------
    triggers {
        // Dispara la construcción al hacer 'git push' al repositorio principal (backend)
        githubPush() 
    }

    tools {
        // Asume que estas herramientas están configuradas en 'Global Tool Configuration'
        maven 'Maven_3.9.10'
        nodejs 'NodeJS_22_18_0'
    }

    environment {
        // ⚠️ 1. CAMBIAR POR EL ID DE TU CREDENCIAL EN JENKINS
        REGISTRY_CREDENTIALS = 'dockerhub-credentials-id'

        // Backend (Java/Maven)
        BACKEND_IMAGE = "lscapini/toolrent-backend:latest"

        // Frontend (Node.js/Nginx)
        FRONTEND_IMAGE = "lscapini/toolrent-frontend:latest"
        // ⚠️ 2. CAMBIAR POR LA URL REAL DE TU REPOSITORIO DEL FRONTEND
        FRONTEND_REPO_URL = 'https://github.com/Scapin1/Frontend-Tingeso'

        // Nombre del subdirectorio donde se clonará el frontend
        FRONTEND_DIR = 'frontend-app'
    }

    // ------------------------------------------------------------------
    // 2. ETAPAS DEL PIPELINE
    // ------------------------------------------------------------------
    stages {

        stage('Checkout Repositorios') {
            steps {
                echo "Clonando Backend (Repositorio principal) a la raíz del workspace..."
                checkout scm

                // Clonación del repositorio del Frontend en el subdirectorio definido
                echo "Clonando Frontend (Repositorio secundario) en '${env.FRONTEND_DIR}'..."
                dir(env.FRONTEND_DIR) {
                    git(
                        url: env.FRONTEND_REPO_URL,
                        branch: 'main' // Asegúrate de que esta es la rama correcta
                    )
                }
            }
        }

        stage('Build & Test Backend') {
            steps {
                // ⚠️ CAMBIO CRÍTICO: Entrar en el subdirectorio 'Web-mono'
                dir('Web-mono') {
                    echo 'Iniciando limpieza, compilación y pruebas del Backend (Maven)...'
                    // Maven se ejecuta DENTRO de C:\...\ToolRent\Web-mono
                    bat 'mvn clean install -DskipTests=false'
                }
            }
            post {
                always {
                    // Actualizar la ruta del reporte JUnit para que apunte DENTRO de 'Web-mono'
                    junit 'Web-mono/target/surefire-reports/*.xml'
                }
            }
        }


        stage('Build Frontend Image (Nginx)') {
            // Asegura el PATH con la versión de Node configurada
            steps {
                tool 'NodeJS_22_18_0'
                // Entra al subdirectorio donde está el código del frontend
                dir(env.FRONTEND_DIR) {
                    echo '1. Instalando dependencias y construyendo el Frontend...'

                    // Crear un archivo .env en tiempo de build usando credenciales seguras de Jenkins.
                    // NOTA: Debes crear en Jenkins 3 credenciales de tipo "Secret text" con estos IDs:
                    // - VITE_API_HOST_CRED
                    // - VITE_API_PORT_CRED
                    // - VITE_KEYCLOAK_URL_CRED
                    // Estos valores nunca se hardcodean ni se suben al repositorio.
                    script {
                        withCredentials([string(credentialsId: 'VITE_API_HOST_CRED', variable: 'VITE_API_HOST'),
                                         string(credentialsId: 'VITE_API_PORT_CRED', variable: 'VITE_API_PORT'),
                                         string(credentialsId: 'VITE_KEYCLOAK_URL_CRED', variable: 'VITE_KEYCLOAK_URL')]) {
                            // Construir el contenido del .env. Vite lee variables que comienzan con VITE_ en tiempo de build.
                            def envContent = """
VITE_API_HOST=${VITE_API_HOST}
VITE_API_PORT=${VITE_API_PORT}
VITE_KEYCLOAK_URL=${VITE_KEYCLOAK_URL}
""".stripIndent()

                            // Escribir el archivo .env en el workspace del frontend (temporal y no versionado)
                            writeFile file: '.env', text: envContent
                            echo 'Archivo .env creado desde credenciales de Jenkins (contenido oculto por seguridad).'
                        }
                    }

                    bat 'npm install'
                    bat 'npm run build'

                    echo '2. Creando la Imagen Docker del Frontend...'
                    script {
                        // Construye la imagen asumiendo que el Dockerfile está en este directorio
                        docker.build("${FRONTEND_IMAGE}")
                    }
                }
            }
        }

        stage('Build Backend Image') {
            steps {
                echo 'Creando Imagen Docker del Backend...'

                dir('Web-mono') {
                    script {
                        // Docker buscará el Dockerfile DENTRO de Web-mono
                        docker.build("${BACKEND_IMAGE}")
                    }
                }
            }
        }

        stage('Push Docker Images') {
            steps {
                echo 'Subiendo ambas imágenes a Docker Hub...'
                script {
                    // Usa la credencial configurada para autenticación
                    docker.withRegistry('', "${REGISTRY_CREDENTIALS}") {
                        docker.image("${FRONTEND_IMAGE}").push()
                        docker.image("${BACKEND_IMAGE}").push()
                    }
                }
            }
        }
    }

    // ------------------------------------------------------------------
    // 3. ACCIONES POST-CONSTRUCCIÓN
    // ------------------------------------------------------------------
    post {
        success {
            echo '✅ Pipeline completado exitosamente. Ambas imágenes subidas.'
        }
        failure {
            echo '❌ El pipeline ha fallado. Revisar logs.'
        }
        // Siempre limpia el workspace al finalizar para liberar espacio
        always {
            cleanWs() 
        }
    }
}